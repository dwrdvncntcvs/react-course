{"ast":null,"code":"import mongoose from \"mongoose\";\n/** \r\nSource : \r\nhttps://github.com/vercel/next.js/blob/canary/examples/with-mongodb-mongoose/utils/dbConnect.js \r\n**/\n\nconst MONGODB_URI = process.env.MONGODB_URI;\n\nif (!MONGODB_URI) {\n  throw new Error(\"Please define the MONGODB_URI environment variable inside .env.local\");\n}\n/**\r\n * Global is used here to maintain a cached connection across hot reloads\r\n * in development. This prevents connections growing exponentially\r\n * during API Route usage.\r\n */\n\n\nlet cached = global.mongoose;\n\nif (!cached) {\n  cached = global.mongoose = {\n    conn: null,\n    promise: null\n  };\n}\n\nasync function dbConnect() {\n  if (cached.conn) {\n    return cached.conn;\n  }\n\n  if (!cached.promise) {\n    const opts = {\n      useNewUrlParser: true,\n      useUnifiedTopology: true,\n      bufferCommands: false,\n      bufferMaxEntries: 0,\n      useFindAndModify: true,\n      useCreateIndex: true\n    };\n    cached.promise = mongoose.connect(MONGODB_URI, opts).then(mongoose => {\n      return mongoose;\n    });\n  }\n\n  cached.conn = await cached.promise;\n  return cached.conn;\n}\n\nexport default dbConnect;","map":{"version":3,"sources":["D:/Builds/Tutorials/React/Section 23/meetup-app/database/mongodb/config.js"],"names":["mongoose","MONGODB_URI","process","env","Error","cached","global","conn","promise","dbConnect","opts","useNewUrlParser","useUnifiedTopology","bufferCommands","bufferMaxEntries","useFindAndModify","useCreateIndex","connect","then"],"mappings":"AAAA,OAAOA,QAAP,MAAqB,UAArB;AAEA;AACA;AACA;AACA;;AAEA,MAAMC,WAAW,GAAGC,OAAO,CAACC,GAAR,CAAYF,WAAhC;;AAEA,IAAI,CAACA,WAAL,EAAkB;AAChB,QAAM,IAAIG,KAAJ,CACJ,sEADI,CAAN;AAGD;AAED;AACA;AACA;AACA;AACA;;;AACA,IAAIC,MAAM,GAAGC,MAAM,CAACN,QAApB;;AAEA,IAAI,CAACK,MAAL,EAAa;AACXA,EAAAA,MAAM,GAAGC,MAAM,CAACN,QAAP,GAAkB;AAAEO,IAAAA,IAAI,EAAE,IAAR;AAAcC,IAAAA,OAAO,EAAE;AAAvB,GAA3B;AACD;;AAED,eAAeC,SAAf,GAA2B;AACzB,MAAIJ,MAAM,CAACE,IAAX,EAAiB;AACf,WAAOF,MAAM,CAACE,IAAd;AACD;;AAED,MAAI,CAACF,MAAM,CAACG,OAAZ,EAAqB;AACnB,UAAME,IAAI,GAAG;AACXC,MAAAA,eAAe,EAAE,IADN;AAEXC,MAAAA,kBAAkB,EAAE,IAFT;AAGXC,MAAAA,cAAc,EAAE,KAHL;AAIXC,MAAAA,gBAAgB,EAAE,CAJP;AAKXC,MAAAA,gBAAgB,EAAE,IALP;AAMXC,MAAAA,cAAc,EAAE;AANL,KAAb;AASAX,IAAAA,MAAM,CAACG,OAAP,GAAiBR,QAAQ,CAACiB,OAAT,CAAiBhB,WAAjB,EAA8BS,IAA9B,EAAoCQ,IAApC,CAA0ClB,QAAD,IAAc;AACtE,aAAOA,QAAP;AACD,KAFgB,CAAjB;AAGD;;AACDK,EAAAA,MAAM,CAACE,IAAP,GAAc,MAAMF,MAAM,CAACG,OAA3B;AACA,SAAOH,MAAM,CAACE,IAAd;AACD;;AAED,eAAeE,SAAf","sourcesContent":["import mongoose from \"mongoose\";\r\n\r\n/** \r\nSource : \r\nhttps://github.com/vercel/next.js/blob/canary/examples/with-mongodb-mongoose/utils/dbConnect.js \r\n**/\r\n\r\nconst MONGODB_URI = process.env.MONGODB_URI;\r\n\r\nif (!MONGODB_URI) {\r\n  throw new Error(\r\n    \"Please define the MONGODB_URI environment variable inside .env.local\"\r\n  );\r\n}\r\n\r\n/**\r\n * Global is used here to maintain a cached connection across hot reloads\r\n * in development. This prevents connections growing exponentially\r\n * during API Route usage.\r\n */\r\nlet cached = global.mongoose;\r\n\r\nif (!cached) {\r\n  cached = global.mongoose = { conn: null, promise: null };\r\n}\r\n\r\nasync function dbConnect() {\r\n  if (cached.conn) {\r\n    return cached.conn;\r\n  }\r\n\r\n  if (!cached.promise) {\r\n    const opts = {\r\n      useNewUrlParser: true,\r\n      useUnifiedTopology: true,\r\n      bufferCommands: false,\r\n      bufferMaxEntries: 0,\r\n      useFindAndModify: true,\r\n      useCreateIndex: true,\r\n    };\r\n\r\n    cached.promise = mongoose.connect(MONGODB_URI, opts).then((mongoose) => {\r\n      return mongoose;\r\n    });\r\n  }\r\n  cached.conn = await cached.promise;\r\n  return cached.conn;\r\n}\r\n\r\nexport default dbConnect;\r\n"]},"metadata":{},"sourceType":"module"}